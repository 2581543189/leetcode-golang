
来源：力扣（LeetCode）  
链接：https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/

给你一个 n x n 矩阵 matrix ，其中每行和每列元素均按升序排序，找到矩阵中第 k 小的元素。
请注意，它是 排序后 的第 k 小元素，而不是第 k 个 不同 的元素


输入：
```
matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8
```
输出：
```
13
矩阵中的元素为 [1,5,9,10,11,12,13,13,15]，第 8 小元素是 13
```

输入：
```
matrix = [[-5]], k = 1
```
输出：
```
-5
```

提示：
    

* n == matrix.length
* n == matrix[i].length
* 1 <= n <= 300
* -109 <= matrix[i][j] <= 109
* 题目数据 保证 matrix 中的所有行和列都按 非递减顺序 排列
* 1 <= k <= n2

总结：
* 按照从左下到右上的顺序遍历有序矩阵，将矩阵分成两部分，如此简单的一件事情花了两天时间，必须要总结一下：
* 不需要两层for 嵌套
* 二分的时候，等于放在左边还是放在右边，调整left 和 right 的时候，就得把中间值放到对应的边
* 如果小于目标值就往右走，如果大于目标值就往上走，这个是固定的，没有别的选择。因为，如果a[x][y] 小于某个值，那么往上走走到a[ x -1 ][y]没有意义因为往上还是小于
* 既然往上走，往右走的条件是固定的，那么到底应该往上走的时候加，还是往右走的时候加可以这么判断：
* 如果往上走的时候加，极端情况下，全部往右走就一次都没加，这个时候统计出来是0，应该统计大于某个值的数量
* 二分查找使用：left + (right - left) / 2，避免（left+right）出现溢出
* 如果 left 和 right 都是负数，left + (right - left) / 2 可以跟正数有相同的表现